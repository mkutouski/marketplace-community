#!/usr/bin/env bash

# Nextcloud SUSE Appliance Installation Script
# Auto-generated by OpenNebula Docker Appliance Generator
# Docker Image: nextcloud/all-in-one:latest

set -o errexit -o pipefail

# List of contextualization parameters
ONE_SERVICE_PARAMS=(
    'ONEAPP_CONTAINER_NAME'     'configure'  'Docker container name'                    'O|text'
    'ONEAPP_CONTAINER_PORTS'    'configure'  'Docker container port mappings'           'O|text'
    'ONEAPP_CONTAINER_ENV'      'configure'  'Docker container environment variables'   'O|text'
    'ONEAPP_CONTAINER_VOLUMES'  'configure'  'Docker container volume mappings'         'O|text'
)

# Configuration from user input
DOCKER_IMAGE="nextcloud/all-in-one:latest"
# IMPORTANT: Nextcloud AIO requires the container to be named exactly "nextcloud-aio-mastercontainer"
# Using any other name will cause the container to fail with error:
# "The 'nextcloud-aio-mastercontainer' container was not found"
DEFAULT_CONTAINER_NAME="nextcloud-aio-mastercontainer"
DEFAULT_PORTS="80:80,8080:8080,8443:8443"
DEFAULT_ENV_VARS="SKIP_DOMAIN_VALIDATION=true"
DEFAULT_VOLUMES="/var/run/docker.sock:/var/run/docker.sock:ro,nextcloud_aio_mastercontainer:/mnt/docker-aio-config"
APP_NAME="Nextcloud SUSE"
APPLIANCE_NAME="nextcloud-suse"

### Appliance metadata ###############################################

ONE_SERVICE_NAME='Nextcloud SUSE'
ONE_SERVICE_VERSION=   #latest
ONE_SERVICE_BUILD=$(date +%s)
ONE_SERVICE_SHORT_DESCRIPTION='Nextcloud SUSE Docker Container Appliance'
ONE_SERVICE_DESCRIPTION='Nextcloud SUSE running in Docker container'
ONE_SERVICE_RECONFIGURABLE=true

### Appliance functions ##############################################

service_cleanup()
{
    :
}

service_install()
{
    # Detect OS family
    if [ -f /etc/os-release ]; then
        . /etc/os-release
        OS_FAMILY=""
        case "$ID" in
            ubuntu|debian|linuxmint)
                OS_FAMILY="debian"
                ;;
            almalinux|rocky|centos|rhel|fedora)
                OS_FAMILY="rhel"
                ;;
            opensuse*|suse|sles)
                OS_FAMILY="suse"
                ;;
            *)
                msg error "Unsupported OS: $ID"
                exit 1
                ;;
        esac
    else
        msg error "Cannot detect OS - /etc/os-release not found"
        exit 1
    fi

    msg info "Detected OS: $ID $VERSION_ID (family: $OS_FAMILY)"

    if [ "$OS_FAMILY" = "debian" ]; then
        install_debian_based
    elif [ "$OS_FAMILY" = "suse" ]; then
        install_suse_based
    else
        install_rhel_based
    fi

    # Common post-install steps
    install_common
}

install_debian_based()
{
    export DEBIAN_FRONTEND=noninteractive

    # Update system
    apt-get update
    apt-get upgrade -y

    # Install generic kernel with Virtual Terminal (VT) support for VNC console
    # The KVM kernel lacks VT support which causes VNC to show a black screen
    msg info "Installing generic kernel for VNC console support"
    apt-get install -y linux-image-generic linux-modules-extra-$(uname -r | sed 's/-kvm$/-generic/') 2>/dev/null || \
        apt-get install -y linux-image-generic || true

    # Set generic kernel as default in GRUB
    if [ -f /etc/default/grub ]; then
        GENERIC_ENTRY=$(grep -E "menuentry.*generic" /boot/grub/grub.cfg 2>/dev/null | head -1 | sed "s/.*'\([^']*\)'.*/\1/" || echo "")
        if [ -n "$GENERIC_ENTRY" ]; then
            sed -i "s/^GRUB_DEFAULT=.*/GRUB_DEFAULT=\"Advanced options for Ubuntu>$GENERIC_ENTRY\"/" /etc/default/grub
        else
            sed -i 's/^GRUB_DEFAULT=.*/GRUB_DEFAULT=0/' /etc/default/grub
        fi
        update-grub
    fi

    # Install Docker
    apt-get install -y ca-certificates curl gnupg
    install -m 0755 -d /etc/apt/keyrings

    # Determine Docker repo based on distro
    local DOCKER_DISTRO="$ID"
    if [ "$ID" = "linuxmint" ]; then
        DOCKER_DISTRO="ubuntu"
    fi

    curl -fsSL "https://download.docker.com/linux/${DOCKER_DISTRO}/gpg" -o /etc/apt/keyrings/docker.asc
    chmod a+r /etc/apt/keyrings/docker.asc

    echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/${DOCKER_DISTRO} $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | tee /etc/apt/sources.list.d/docker.list > /dev/null

    apt-get update
    apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin

    # Configure console auto-login
    systemctl stop unattended-upgrades 2>/dev/null || true
    systemctl disable unattended-upgrades 2>/dev/null || true

    apt-get install -y mingetty || true
}

install_rhel_based()
{
    # Update system
    dnf update -y

    # Install Docker
    msg info "Installing Docker on RHEL-based system"
    dnf install -y dnf-plugins-core
    dnf config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
    dnf install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin

    # Install mingetty equivalent
    dnf install -y util-linux || true
}

install_suse_based()
{
    # Update system
    zypper refresh
    zypper update -y

    # Install Docker
    msg info "Installing Docker on openSUSE/SUSE system"
    zypper install -y docker docker-compose

    # Install util-linux for console support
    zypper install -y util-linux || true
}

install_common()
{
    # Enable and start Docker
    systemctl enable docker
    systemctl start docker

    # Pull the Docker image
    msg info "Pulling Docker image: $DOCKER_IMAGE"
    docker pull "$DOCKER_IMAGE"

    # Create TTY devices at boot (fallback for kernels without VT support)
    cat > /etc/systemd/system/create-tty-devices.service << 'TTY_SERVICE_EOF'
[Unit]
Description=Create TTY device nodes for KVM kernel
DefaultDependencies=no
Before=getty@tty1.service
After=systemd-tmpfiles-setup-dev.service

[Service]
Type=oneshot
ExecStart=/bin/bash -c 'for i in 0 1 2 3 4 5 6; do [ -e /dev/tty\$i ] || mknod /dev/tty\$i c 4 \$i; done'
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
TTY_SERVICE_EOF
    systemctl enable create-tty-devices.service

    # Configure auto-login on console (for VT-enabled kernels)
    mkdir -p /etc/systemd/system/getty@tty1.service.d
    cat > /etc/systemd/system/getty@tty1.service.d/override.conf << 'CONSOLE_EOF'
[Unit]
# Remove ConditionPathExists to avoid skipping on KVM kernels
ConditionPathExists=

[Service]
ExecStart=
ExecStart=-/sbin/agetty --noissue --autologin root %I $TERM
Type=idle
CONSOLE_EOF

    # Configure serial console (PRIMARY console for cloud VMs)
    # Serial console works reliably with KVM-optimized kernels
    mkdir -p /etc/systemd/system/serial-getty@ttyS0.service.d
    cat > /etc/systemd/system/serial-getty@ttyS0.service.d/override.conf << 'SERIAL_EOF'
[Service]
ExecStart=
ExecStart=-/sbin/agetty --noissue --autologin root %I 115200,38400,9600 vt102
Type=idle
SERIAL_EOF

    echo 'root:opennebula' | chpasswd
    systemctl enable getty@tty1.service serial-getty@ttyS0.service

    # Create welcome message
    cat > /etc/profile.d/99-${APPLIANCE_NAME}-welcome.sh << WELCOME_EOF
#!/bin/bash
case \$- in
    *i*) ;;
      *) return;;
esac

echo "=================================================="
echo "  $APP_NAME Appliance"
echo "=================================================="
echo "  Docker Image: $DOCKER_IMAGE"
echo "  Container: $DEFAULT_CONTAINER_NAME"
echo "  Ports: $DEFAULT_PORTS"
echo ""
echo "  Commands:"
echo "    docker ps                    - Show running containers"
echo "    docker logs $DEFAULT_CONTAINER_NAME   - View container logs"
echo "    docker exec -it $DEFAULT_CONTAINER_NAME /bin/bash - Access container"
echo ""
echo "  Access Methods:"
echo "    SSH: Enabled (password: 'opennebula' + context SSH keys)"
echo "    VNC Console: Enabled (via OpenNebula Sunstone)"
echo "    Serial Console: Enabled (virsh console or Sunstone serial)"
echo ""
echo "  Default root password: opennebula"
echo "=================================================="
WELCOME_EOF

    chmod +x /etc/profile.d/99-${APPLIANCE_NAME}-welcome.sh

    # Clean up based on OS family
    if [ "$OS_FAMILY" = "debian" ]; then
        apt-get autoremove -y
        apt-get autoclean
    elif [ "$OS_FAMILY" = "suse" ]; then
        zypper clean --all
    else
        dnf clean all
    fi
    find /var/log -type f -exec truncate -s 0 {} \;

    sync

    return 0
}

service_configure()
{
    msg info "Configuring network and services"

    # Ensure DNS is configured (virt-sysprep deletes /etc/resolv.conf during image preparation)
    # This is critical for Nextcloud AIO which needs to reach ghcr.io to pull container images
    configure_dns

    msg info "Verifying Docker is running"

    if ! systemctl is-active --quiet docker; then
        msg error "Docker is not running"
        return 1
    fi

    msg info "Docker is running"
    return 0
}

# Configure DNS nameservers
# This is critical for Nextcloud AIO which needs to reach external registries
configure_dns()
{
    msg info "Checking DNS configuration..."

    # Check if DNS is already working
    if host google.com > /dev/null 2>&1; then
        msg info "DNS is already working"
        return 0
    fi

    # If resolv.conf is empty, missing, or has no valid nameservers
    if [ ! -s /etc/resolv.conf ] || ! grep -q "^nameserver" /etc/resolv.conf 2>/dev/null; then
        msg info "Setting up DNS nameservers (fallback configuration)"
        cat > /etc/resolv.conf << 'EOF'
# Fallback DNS configuration for Nextcloud AIO
# Added by OpenNebula appliance service
nameserver 8.8.8.8
nameserver 1.1.1.1
nameserver 8.8.4.4
EOF
    fi

    # Verify DNS is now working
    if host google.com > /dev/null 2>&1; then
        msg info "DNS configuration successful"
    else
        msg warning "DNS may not be fully configured - container startup might fail"
    fi

    return 0
}

service_bootstrap()
{
    msg info "Starting $APP_NAME service bootstrap"

    # Setup and start the container
    setup_app_container

    return $?
}

# Setup container function
setup_app_container()
{
    local container_name="${ONEAPP_CONTAINER_NAME:-$DEFAULT_CONTAINER_NAME}"
    local container_ports="${ONEAPP_CONTAINER_PORTS:-$DEFAULT_PORTS}"
    local container_env="${ONEAPP_CONTAINER_ENV:-$DEFAULT_ENV_VARS}"
    local container_volumes="${ONEAPP_CONTAINER_VOLUMES:-$DEFAULT_VOLUMES}"

    msg info "Setting up $APP_NAME container: $container_name"

    # Stop and remove existing container if it exists
    if docker ps -a --format '{{.Names}}' | grep -q "^${container_name}$"; then
        msg info "Stopping existing container: $container_name"
        docker stop "$container_name" 2>/dev/null || true
        docker rm "$container_name" 2>/dev/null || true
    fi

    # Parse port mappings
    local port_args=""
    if [ -n "$container_ports" ]; then
        IFS=',' read -ra PORT_ARRAY <<< "$container_ports"
        for port in "${PORT_ARRAY[@]}"; do
            port_args="$port_args -p $port"
        done
    fi

    # Parse environment variables
    local env_args=""
    if [ -n "$container_env" ]; then
        IFS=',' read -ra ENV_ARRAY <<< "$container_env"
        for env in "${ENV_ARRAY[@]}"; do
            env_args="$env_args -e $env"
        done
    fi

    # Parse volume mounts
    local volume_args=""
    if [ -n "$container_volumes" ]; then
        IFS=',' read -ra VOL_ARRAY <<< "$container_volumes"
        for vol in "${VOL_ARRAY[@]}"; do
            local host_path=$(echo "$vol" | cut -d':' -f1)
            # Only create directory if it doesn't exist and is not a socket/device file
            if [ ! -e "$host_path" ]; then
                mkdir -p "$host_path"
                # Set ownership to 1000:1000 (common for Docker containers)
                chown -R 1000:1000 "$host_path" 2>/dev/null || true
            fi
            volume_args="$volume_args -v $vol"
        done
    fi

    # Start the container
    msg info "Starting $APP_NAME container with:"
    msg info "  Ports: $container_ports"
    msg info "  Environment: ${container_env:-none}"
    msg info "  Volumes: $container_volumes"

    docker run -d --name "$container_name" --restart unless-stopped $port_args $env_args $volume_args "$DOCKER_IMAGE"

    if [ $? -eq 0 ]; then
        msg info "$APP_NAME container started successfully"
        docker ps --filter name="$container_name"
        return 0
    else
        msg error "Failed to start $APP_NAME container"
        return 1
    fi
}
